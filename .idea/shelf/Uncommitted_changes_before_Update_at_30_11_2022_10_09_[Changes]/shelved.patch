Index: src/window.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <stdio.h>\r\n#include <SDL.h>\r\n#include <stdbool.h>\r\n#include \"window.h\"\r\n#include \"init_Plateau.h\"\r\n#include \"parsing.h\"\r\n#include \"play.h\"\r\n\r\n#define WIN_SIZE 800\r\n\r\nint Update(SDL_Renderer *renderer, int taille, SDL_Rect cases[]) {\r\n    int reste = WIN_SIZE%taille;\r\n    SDL_SetRenderDrawColor(renderer, 255, 0, 255, 255);\r\n    SDL_RenderClear(renderer);\r\n    for(int i=0; i<taille; i++){\r\n        for(int j=0; j<taille; j++){\r\n            cases[(taille*i)+j].y = i*(WIN_SIZE/taille)+reste/2;\r\n            cases[(taille*i)+j].x = j*(WIN_SIZE/taille)+reste/2;\r\n            cases[(taille*i)+j].w = cases[(taille*i)+j].h = WIN_SIZE/taille;\r\n            if((i+j)%2 == 0){\r\n                SDL_SetRenderDrawColor(renderer, 176, 95, 40, 255);\r\n                SDL_RenderFillRect(renderer,&cases[(taille*i)+j]);\r\n            }\r\n            else{\r\n                SDL_SetRenderDrawColor(renderer, 224, 156, 110, 255);\r\n                SDL_RenderFillRect(renderer,&cases[(taille*i)+j]);\r\n            }\r\n        }\r\n    }\r\n    SDL_RenderPresent(renderer);\r\n}\r\n\r\n/*\r\nint FrameUpdate(SDL_Event e, SDL_Renderer *renderer, int nb_cases, SDL_Rect cases[], SDL_Surface* King, SDL_Surface* WhitePawn, SDL_Surface* BlackPawn){\r\n    int x, y;\r\n    SDL_GetMouseState(&x,&y);\r\n    SDL_Point mouse_point;\r\n    mouse_point.x = x;\r\n    mouse_point.y = y;\r\n    HoverEffect(renderer, mouse_point, cases, nb_cases);\r\n}\r\n*/\r\n\r\nvoid PlacePieces(SDL_Renderer *renderer, SDL_Rect cases[], int TableauNoir[], int TableauBlanc[], int TableauForteresses[], int Roi, int taille){\r\n    int nbPieceBlanche = taille-1;\r\n    int nbPieceNoire = (taille-1)*2;\r\n    int nb_cases = taille*taille;\r\n    SDL_Color color;\r\n\r\n    for(int i=0; i<nb_cases; i++){\r\n        color.r = 255; color.g = 255; color.b = 255;\r\n        for(int j=0; j<nbPieceBlanche; j++) {\r\n            if(i==TableauBlanc[j]){\r\n                DrawPiece(renderer, cases[i], color, taille);\r\n            }\r\n        }\r\n        color.r = 0; color.g = 0; color.b =0;\r\n        for(int k=0; k<nbPieceNoire; k++){\r\n            if(i==TableauNoir[k]){\r\n                DrawPiece(renderer, cases[i], color, taille);\r\n            }\r\n        }\r\n        color.r = 150; color.g = 150; color.b = 150;\r\n        for(int l=0; l<4; l++){\r\n            if(i==TableauForteresses[l]){\r\n                DrawPiece(renderer, cases[i], color, taille);\r\n            }\r\n        }\r\n        color.r = 255; color.g = 220; color.b = 125;\r\n        if(i==Roi){\r\n            DrawPiece(renderer, cases[i], color, taille);\r\n        }\r\n    }\r\n    SDL_RenderPresent(renderer);\r\n}\r\n\r\nvoid DrawPiece(SDL_Renderer *renderer, SDL_Rect rect, SDL_Color color, int taille){\r\n    if(color.r == 150){\r\n        SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, 255);\r\n        SDL_Rect fillRect;\r\n        fillRect.x = rect.x;\r\n        fillRect.y = rect.y;\r\n        fillRect.w = fillRect.h = (WIN_SIZE/taille);\r\n        SDL_RenderFillRect(renderer,&fillRect);\r\n    }\r\n    else{\r\n        SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, 255);\r\n        SDL_Rect fillRect;\r\n        fillRect.x = rect.x + (WIN_SIZE/taille)*0.1;\r\n        fillRect.y = rect.y + (WIN_SIZE/taille)*0.1;\r\n        fillRect.w = fillRect.h = (WIN_SIZE/taille)*0.8;\r\n        SDL_RenderFillRect(renderer,&fillRect);\r\n    }\r\n}\r\n\r\nint windowCreation(int taille, bool restart,int debut) {\r\n    int nb_cases = taille*taille;\r\n    SDL_Rect cases[nb_cases];\r\n\r\n    SDL_Init(SDL_INIT_EVERYTHING);\r\n    SDL_Window *window = SDL_CreateWindow(\"Tablut\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, WIN_SIZE, WIN_SIZE, SDL_WINDOW_SHOWN);\r\n    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\r\n    int *TableauNoir = (int*) malloc(((taille-1)*2)*sizeof(int));\r\n    int *TableauBlanc = (int*) malloc((taille-1)*sizeof(int));\r\n    int TableauForteresses[4];\r\n    int tableauPiege[2];\r\n    int Roi;\r\n    int mode=0;\r\n    if(restart == false){\r\n        Roi = init_Plateau(taille, TableauBlanc, TableauNoir, TableauForteresses,tableauPiege,mode);\r\n    }\r\n    else{\r\n        Roi = parsing_open(TableauBlanc, TableauNoir, TableauForteresses);\r\n    }\r\n    Update(renderer, taille, cases);\r\n    PlacePieces(renderer, cases, TableauNoir, TableauBlanc, TableauForteresses, Roi, taille);\r\n    SDL_RenderPresent(renderer);\r\n    debut = 1;\r\n\r\n\r\n    //Boucle principale\r\n    bool quit = false;\r\n    Update(renderer, taille, cases);\r\n    PlacePieces(renderer, cases, TableauNoir, TableauBlanc, TableauForteresses, Roi, taille);\r\n    SDL_RenderPresent(renderer);\r\n    int DepartQuad = -1;\r\n    while(quit != true) {\r\n        SDL_Event e;\r\n        SDL_WaitEvent(&e);\r\n        switch (e.type) {\r\n            case SDL_QUIT:\r\n                QuitEvent(renderer, window, TableauNoir, TableauBlanc, TableauForteresses, Roi, taille);\r\n                quit = true;\r\n                break;\r\n            case SDL_MOUSEBUTTONDOWN:\r\n                DepartQuad = GetQuadrant(cases, nb_cases);\r\n                break;\r\n            case SDL_MOUSEBUTTONUP:\r\n                MouseInteraction(DepartQuad, cases, nb_cases, renderer);\r\n\r\n                PlacePieces(renderer, cases, TableauNoir, TableauBlanc, TableauForteresses, Roi, taille);\r\n                break;\r\n        }\r\n        //FrameUpdate(e, renderer, nb_cases, cases, King, White, Black);\r\n    }\r\n    return 0;\r\n}\r\n/*\r\nvoid HoverEffect(SDL_Renderer* renderer, SDL_Point mouse_point, SDL_Rect cases[], int nb_cases){\r\n    for (int i=0; i<nb_cases; i++) {\r\n        if (SDL_PointInRect(&mouse_point, &cases[i]) == true) {\r\n            if((i)%2 == 0){\r\n                SDL_SetRenderDrawColor(renderer, 196, 115, 60, 255);\r\n                SDL_RenderFillRect(renderer,&cases[i]);\r\n                SDL_RenderPresent(renderer);\r\n            }\r\n            else{\r\n                SDL_SetRenderDrawColor(renderer, 244, 176, 130, 255);\r\n                SDL_RenderFillRect(renderer,&cases[i]);\r\n                SDL_RenderPresent(renderer);\r\n            }\r\n        }\r\n        else{\r\n            if((i)%2 == 0){\r\n                SDL_SetRenderDrawColor(renderer, 176, 95, 40, 255);\r\n                SDL_RenderFillRect(renderer,&cases[i]);\r\n                SDL_RenderPresent(renderer);\r\n            }\r\n            else{\r\n                SDL_SetRenderDrawColor(renderer, 224, 156, 110, 255);\r\n                SDL_RenderFillRect(renderer,&cases[i]);\r\n                SDL_RenderPresent(renderer);\r\n            }\r\n        }\r\n    }\r\n}*/\r\n\r\nvoid QuitEvent(SDL_Renderer *renderer, SDL_Window *window, int* TableauNoir, int* TableauBlanc, int TableauForteresses[], int Roi, int taille) {\r\n    SDL_DestroyRenderer(renderer);\r\n    SDL_DestroyWindow(window);\r\n    parsing_write(TableauNoir, TableauBlanc, TableauForteresses, Roi, taille);\r\n    printf(\"[DEBUG] : Closed Window\");\r\n    SDL_Quit();\r\n}\r\n\r\nvoid OnButtonClick(SDL_Rect cases[], int nb_cases, SDL_Renderer *renderer){\r\n    int quadrant = GetQuadrant(cases, nb_cases);\r\n    if(quadrant != -1){\r\n        printf(\"[DEBUG] : Clicked on the %dth Quadrant\\n\", quadrant);\r\n    }\r\n}\r\n\r\nint GetQuadrant(SDL_Rect cases[], int nb_cases){\r\n    int x, y, quadrant = -1;\r\n    SDL_GetMouseState(&x,&y);\r\n    SDL_Point mouse_point;\r\n    mouse_point.x = x;\r\n    mouse_point.y = y;\r\n    for(int i = 0; i<nb_cases; i++){\r\n        if(SDL_PointInRect(&mouse_point, &cases[i])){\r\n            quadrant = i;\r\n        }\r\n    }\r\n    return quadrant;\r\n}\r\n\r\nvoid MouseInteraction(int IndexDepart, SDL_Rect cases[], int nb_cases, SDL_Renderer *renderer){\r\n    int IndexArrive;\r\n    IndexArrive = GetQuadrant(cases, nb_cases);\r\n    if(IndexDepart != IndexArrive){\r\n        DragPiece(IndexDepart, IndexArrive);\r\n    }\r\n    else{\r\n        OnButtonClick(cases, nb_cases, renderer);\r\n    }\r\n}\r\n\r\nint DragPiece(int IndexDepart, int IndexArrive) {\r\n    printf(\"[DEBUG] : Dragged From %d to %d th quadrant\\n\", IndexDepart, IndexArrive);\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/window.c b/src/window.c
--- a/src/window.c	(revision 50ae9b5cb51e5394506cd86551502cd4c74ea029)
+++ b/src/window.c	(date 1669799355311)
@@ -137,7 +137,6 @@
                 break;
             case SDL_MOUSEBUTTONUP:
                 MouseInteraction(DepartQuad, cases, nb_cases, renderer);
-
                 PlacePieces(renderer, cases, TableauNoir, TableauBlanc, TableauForteresses, Roi, taille);
                 break;
         }
Index: src/play.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n#include \"play.h\"\r\n#include <stdbool.h>\r\n#include <stdio.h>\r\n#include \"window.h\"\r\n\r\nbool sameCase(int king, int *pieceBlanche, int *pieceNoire, int *forteresse,int nbPieceBlanche, int nbPieceNoire,int IndexArrive){\r\n    bool same=false;\r\n    int i;\r\n    for(i=0;i<nbPieceNoire;i++) {\r\n        if (pieceNoire[i] == IndexArrive) {\r\n            same = true;\r\n        }\r\n    }\r\n    for(i=0;i<nbPieceBlanche;i++){\r\n        if(pieceBlanche[i]==IndexArrive){\r\n            same = true;\r\n        }\r\n    }\r\n    for (i=0;i<4;i++){\r\n        if(forteresse[i]==IndexArrive){\r\n            same = true;\r\n        }\r\n    }\r\n    if(IndexArrive == king){\r\n        same = true;\r\n    }\r\n    if(same == true){\r\n        printf(\"La case est deja prise\\n\");\r\n    }\r\n    /*\r\n    for (i=0;i<2;i++){\r\n        if (piege[i]==quadrant){\r\n            pieceBlanche[piece]=Null}\r\n    }*/\r\n\r\n    return same;\r\n}\r\n\r\nbool mouvement(int IndexArrive, int IndexDepart,int taille,int couleur,int *pieceBlanche,int *pieceNoire,int nbPieceBlanche, int nbPieceNoire, int *forteresse){\r\n    bool mov = false;\r\n    int i,k;\r\n    if(IndexDepart == IndexArrive){\r\n        printf(\"bouger une piece\\n\");\r\n    }\r\n    for(i=0;i<taille-1;i++){// au max 8 pour une taille de 9 par exemple\r\n        if(IndexDepart-taille*i == IndexArrive || IndexDepart+taille*i == IndexArrive || IndexDepart+i == IndexArrive\r\n           || IndexDepart-i == IndexArrive){\r\n            printf(\"mov ok\\n\");\r\n            mov = true;\r\n        }\r\n        else{\r\n            mov = false;\r\n            printf(\"mov pas ok\\n\");\r\n        }\r\n    }\r\n    if(IndexArrive == taille/2+(taille/2)*taille){ // position case du milieu\r\n        mov = false;\r\n        printf(\"mov  pas ok car pos milieu\\n\");\r\n    }\r\n    i=0;\r\n    while((IndexDepart-taille*i)/taille !=0 || (IndexDepart+taille*i)/taille != taille-1 || (IndexDepart+i)%taille != taille-1 || (IndexDepart-i)%taille !=0 ){ // verif tant qu'on a pas atteind le bord\r\n        for(k=0;k<nbPieceBlanche;k++){ // plus de piece noire que blanche donc on verifie pour toute les piece nois\r\n            if(IndexDepart-taille*i == pieceBlanche[k] || IndexDepart+taille*i == pieceBlanche[k] ||\r\n               IndexDepart+i == pieceBlanche[k] || IndexDepart-i == pieceBlanche[k]){ // verif pas de pion sur le passage\r\n                printf(\"mov pas ok car pion sur le passage \\n\");\r\n                mov = false;\r\n            }\r\n        }\r\n        for(k=0;k<nbPieceNoire;k++){\r\n            if(IndexDepart-taille*i == pieceNoire[k] || IndexDepart+taille*i == pieceNoire[k] || IndexDepart+i == pieceNoire[k]\r\n               || IndexDepart-i == pieceNoire[k]){\r\n                printf(\"mov pas ok car pion sur le passage \\n\");\r\n                mov = false;\r\n            }\r\n        }\r\n        i++;\r\n    }\r\n    return mov;\r\n}\r\nint pionMange(int IndexArrive,int IndexDepart, int couleur, int* pieceBlanche, int* pieceNoire, int nbPieceBlanche, int nbPieceNoire,int taille,int king){\r\n    int i,k,index;\r\n    if (couleur == 0){\r\n        for (i=0;i<nbPieceBlanche;i++){\r\n            if(pieceBlanche[i]==IndexDepart){\r\n                index = i;\r\n            }\r\n        }\r\n        for(i=0;i<nbPieceNoire;i++){\r\n            if(IndexArrive-taille == pieceNoire[i]){ // pion en haut\r\n                for(k=0;k<nbPieceBlanche;k++){\r\n                    if(IndexArrive-2*taille==pieceBlanche[k] || IndexArrive-2*taille == king){\r\n                        printf(\"pion noir mange en haut:%d\\n\",pieceNoire[i]);\r\n                        pieceNoire[i] = -1;\r\n                    }\r\n                }\r\n            }\r\n            if(IndexArrive+taille == pieceNoire[i]){ // pion en bas\r\n                for(k=0;k<nbPieceBlanche;k++){\r\n                    if(IndexArrive+2*taille==pieceBlanche[k] || IndexArrive+2*taille == king){\r\n                        printf(\"pion noir mange en bas:%d\\n\",pieceNoire[i]);\r\n                        pieceNoire[i] = -1;\r\n                    }\r\n                }\r\n            }\r\n            if(IndexArrive+1 == pieceNoire[i] && IndexArrive%taille <= taille-3){ // pion a droite + verif assez de case sur le cote\r\n                for(k=0;k<nbPieceBlanche;k++){\r\n                    if(IndexArrive+2==pieceBlanche[k] || IndexArrive+2 == king)\r\n                        printf(\"pion noir mange a droite:%d\\n\",pieceNoire[i]);\r\n                        pieceNoire[i] = -1;\r\n                    }\r\n                }\r\n            }\r\n            if(IndexArrive-1 == pieceNoire[i] && IndexArrive%taille >= 2){ // pion a gauche + verif assez de cases sur le cote\r\n                for(k=0;k<nbPieceBlanche;k++){\r\n                    if(IndexArrive-2==pieceBlanche[k] || IndexArrive-2 == king){\r\n                        printf(\"pion noir mange à gauche:%d\\n\",pieceNoire[i]);\r\n                        pieceNoire[i] = -1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    if (couleur == 1){\r\n        if(IndexArrive-taille == king){ // roi mangé par le haut\r\n            for(k=0;k<nbPieceNoire;k++){\r\n                if(IndexArrive-2*taille == pieceNoire[k]){\r\n                    printf(\"roi blanc mange en haut:%d\\n\",king);\r\n                    king = -1;\r\n                }\r\n            }\r\n        }\r\n        if(IndexArrive+taille == king){ // roi mangé par le bas\r\n            for(k=0;k<nbPieceNoire;k++){\r\n                if(IndexArrive+2*taille == pieceNoire[k]){\r\n                    printf(\"roi blanc mange en bas:%d\\n\",king);\r\n                    king = -1;\r\n                }\r\n            }\r\n        }\r\n        if(IndexArrive-1 == king){ // roi mangé par la gauche\r\n            for(k=0;k<nbPieceNoire;k++){\r\n                if(IndexArrive-2 == pieceNoire[k]){\r\n                    printf(\"roi blanc mange a gauche:%d\\n\",king);\r\n                    king = -1;\r\n                }\r\n            }\r\n        }\r\n        if(IndexArrive+1 == king){ // roi mangé par la droite\r\n            for(k=0;k<nbPieceNoire;k++){\r\n                if(IndexArrive+2 == pieceNoire[k]){\r\n                    printf(\"roi blanc mange a droite:%d\\n\",king);\r\n                    king = -1;\r\n                }\r\n            }\r\n        }\r\n        for(i=0;i<nbPieceBlanche;i++){ // parcours tout le tab blanc\r\n            if(IndexArrive-taille == pieceBlanche[i]){ // pion en haut\r\n                for(k=0;k<nbPieceNoire;k++){\r\n                    if(IndexArrive-2*taille==pieceNoire[k]){\r\n                        printf(\"pion blanc mange en haut:%d\\n\",pieceBlanche[i]);\r\n                        pieceBlanche[i] = -1;\r\n                    }\r\n                }\r\n            }\r\n            if(IndexArrive+taille == pieceBlanche[i]){ // pion en bas\r\n                for(k=0;k<nbPieceNoire;k++){\r\n                    if(IndexArrive+2*taille==pieceNoire[k]){\r\n                        printf(\"pion blanc mange en bas:%d\\n\",pieceBlanche[i]);\r\n                        pieceBlanche[i] = -1;\r\n                    }\r\n                }\r\n            }\r\n            if(IndexArrive+1 == pieceBlanche[i] && IndexArrive%taille <= taille-3){ // pion a droite + verif assez de case sur le cote\r\n                for(k=0;k<nbPieceNoire;k++){\r\n                    if(IndexArrive+2==pieceNoire[k]){\r\n                        printf(\"pion blanc mange à droite:%d\\n\",pieceBlanche[i]);\r\n                        pieceBlanche[i] = -1;\r\n                    }\r\n                }\r\n            }\r\n            if(IndexArrive-1 == pieceBlanche[i] && IndexArrive%taille >= 2){ // pion a gauche + verif assez de cases sur le cote\r\n                for(k=0;k<nbPieceNoire;k++){\r\n                    if(IndexArrive-2==pieceNoire[k]){\r\n                        printf(\"pion blanc mange gauche:%d\\n\",pieceBlanche[i]);\r\n                        pieceBlanche[i] = -1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    movPieces(IndexDepart,IndexArrive,pieceNoire,pieceBlanche,king,couleur,nbPieceBlanche,nbPieceNoire);\r\n}\r\n\r\nint movPieces(int IndexDepart,int IndexArrive, int *pieceNoire, int *pieceBlanche, int king,int couleur, int nbPieceBlanche, int nbPieceNoire){\r\n    int index,i;\r\n    if (couleur == 0){\r\n        if(IndexDepart == king){\r\n            king = IndexArrive;\r\n        }\r\n        for (i=0;i<nbPieceBlanche;i++){\r\n            if(pieceBlanche[i]==IndexDepart){\r\n                index = i;\r\n            }\r\n        }\r\n        pieceBlanche[index]=IndexArrive;\r\n    }\r\n    if (couleur == 1){\r\n        for (i=0;i<nbPieceNoire;i++){\r\n            if(pieceNoire[i]==IndexDepart){\r\n                index = i;\r\n            }\r\n        }\r\n        pieceNoire[index]=IndexArrive;\r\n    }\r\n}\r\n\r\nint play(int IndexArrive,int IndexDepart,int taille,int *pieceNoire, int *pieceBlanche,int *forteresse, int king, int couleur){\r\n    int i,indexBlanc,indexNoir; //si couleur=0 alors c'est au blanc de jouer si =1 c'est au noir\r\n    bool same,win=false,mov;\r\n    int nbPieceBlanche = taille -1;\r\n    int nbPieceNoire =  (taille-1)*2;\r\n    // test si'il n'y a pas déja un pion\r\n    same = sameCase(king, pieceBlanche, pieceNoire, forteresse,nbPieceBlanche,nbPieceNoire,IndexArrive);\r\n    //test movement\r\n    if(same==false){\r\n        mov = mouvement(IndexArrive,IndexDepart,taille, couleur,pieceBlanche, pieceNoire, nbPieceBlanche, nbPieceNoire, forteresse );\r\n    }\r\n    if(same ==false && mov == true){\r\n        pionMange(IndexArrive,IndexDepart, couleur, pieceBlanche, pieceNoire, nbPieceBlanche,nbPieceNoire,taille,king);\r\n    }\r\n\r\n\r\n}\r\n// couleur, taille, king , tab blanc, tab noir, forteresse, indexarrive, indexdepart\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/play.c b/src/play.c
--- a/src/play.c	(revision 50ae9b5cb51e5394506cd86551502cd4c74ea029)
+++ b/src/play.c	(date 1669799355326)
@@ -212,6 +212,7 @@
         }
         pieceNoire[index]=IndexArrive;
     }
+
 }
 
 int play(int IndexArrive,int IndexDepart,int taille,int *pieceNoire, int *pieceBlanche,int *forteresse, int king, int couleur){
